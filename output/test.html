<!doctype html>
<html lang="sv">
<head>
    <meta charset="utf-8">
    <meta name="author" content="Emil Folino">
    <meta name="description" content="Kursplats för kursen DV1612 JavaScript-baserade webbramverk också kallad jsramverk vid Blekinge Tekniska Högskola">
    <meta name="keywords" content="JavaScript,javascript,ramverk,framework,BTH,webbprogrammering">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>jsramverk</title>
    <style>*{margin:0;padding:0;box-sizing:border-box}html{scroll-behavior:smooth;font-size:100%}body{font-family:sans-serif;font-display:auto;line-height:1.4}.header{width:100%;padding:1.4rem 1rem;background:linear-gradient(45deg, #f0db4f, #f4e57e);box-shadow:2px 2px 5px 0 rgba(0,0,0,.2);z-index:1000}.header h1{margin-bottom:0}.header a{color:#323330;text-decoration:none}.header a:hover{text-decoration:underline}.container,.inner-footer{width:100%;margin-top:2rem;padding:1.4rem 1rem;overflow:auto}::selection,::-moz-selection{background:#f0db4f}.main-title{font-size:2.4rem;margin-bottom:1.4rem}.toc{display:none}@media(min-width: 768px){.container,.inner-footer{width:740px;margin-left:auto;margin-right:auto}.main-title{font-size:3rem;margin-bottom:1.4rem}}@media(min-width: 992px){.container,.inner-footer{width:960px}.week-container{width:100%;margin-bottom:16rem}.week{width:auto;margin-left:350px}.main-title{font-size:4rem;margin-bottom:1.61rem}h1{font-size:3.45rem;margin-bottom:1.61rem}h2{font-size:2.76rem;margin-bottom:1.61rem}h3{font-size:2.3rem;margin-bottom:1.61rem}h4{font-size:1.955rem;margin-bottom:1.61rem}p{font-size:1.15rem;margin-bottom:1.61rem}blockquote{margin-bottom:1.61rem}blockquote p{font-size:1.3225rem;margin-bottom:0}.toc{width:310px;display:block;text-align:right;position:fixed;top:14.5rem}.toc ul{list-style-type:none;font-size:1.4rem}}@media(min-width: 1200px){.container,.inner-footer{width:1160px}}/*# sourceMappingURL=inline.min.css.map */
</style>
    <link rel="stylesheet" href="inter-ui.min.css" media="none" onload="if(media!='all')media='all'">
    <link rel="stylesheet" href="style.min.css" media="none" onload="if(media!='all')media='all'">
    
    <script src="bundle.js" defer></script>
    <noscript>
        <link rel="stylesheet" href="style.min.css">
    </noscript>
</head>
<body>
    <header class="header">
        <h1><a href="/">jsramverk.me</a></h1>
    </header>

    <main class="container">
<p class='breadcrump'><a href='/'>jsramverk.me</a> / Test</p><div class='week-container'><nav class='toc' id='toc'><ul><li><a href='#test'>Test</a></li><li><a href='#lasa'>Läsa</a></li><li><a href='#material-och-tekniker'>Material och tekniker</a></li><li><a href='#kravspec'>kravspec</a></li></ul></nav><article class='week'><section id="test"><h1><a href="#test">Test</a></h1>
<p>Vi skapar en testmiljö för både frontend och backend kod, samt ett flöde för Continouos Integration.</p>
<p>Tanken är att vi förbereder oss för ett större utvecklingsprojekt i JavaScript och vi vill säkerställa att vi har en utvecklingsmiljö där vi kan testa vår programvara.</p>
<p>Vilken typ av tester vill vi göra och vilka verktyg kan hjälpa oss med detta? Låt oss gå igenom läget i JavaScript och använda några testrelaterade verktyg för att sätta en grund.</p>
</section><section id="lasa"><h2><a href="#lasa">Läsa</a></h2>
<ol>
<li>
<p>Webbplatsen för <a href="https://mochajs.org/">Mocha</a> ger dig en översikt av ett verktyg för att testa din JavaScript-kod med enhetstester. Du skall själv välja ett eget testverktyg att använda, Mocha är en av möjligheterna.</p>
</li>
<li>
<p>Verktyget <a href="https://istanbul.js.org/">Istanbul</a> kan kopplas till Mocha för att hantera kodtäckning vid enhetstester.</p>
</li>
<li>
<p>Det finns en forumtråd med tips om <a href="t/6984">artiklar för testning</a>. Kika där för inspiration.</p>
</li>
</ol>
</section><section id="material-och-tekniker"><h2><a href="#material-och-tekniker">Material och tekniker</a></h2>
<p>Vi börjar med att skapa oss en överblick över olika typer av test.</p>
<h4 id="enhetstestning"><a href="#enhetstestning">Enhetstestning</a></h4>
<p>På engelska blir det <em>unit testing</em> (<a href="https://en.wikipedia.org/wiki/Unit_testing">Wikipedia om Unit Testing</a>) och det handlar om att testa varje enhet av kod för sig själv. Det är <em>white box testing</em> (<a href="https://en.wikipedia.org/wiki/White-box_testing">Wikipedia om White box testing</a>) eftersom vi har full insyn i koden vi testar. Vi kan se källkoden och vi kan se att våra testfall verkligen exekverar alla delar av koden, förutsatt att vi använder oss av verktyg för kodtäckning, code coverage (<a href="https://en.wikipedia.org/wiki/Code_coverage">Wikipedia om Code Coverage</a>). Att se kodtäckningen är viktigt i enhetstesterna, annars gör vi det onödigt svårt för oss. Kodtäckning är också ett sätt att visa för utomstående hur mycket av kodbasen som är testad via enhetstester. Att nå 100% i kodtäckning är bra, men man nöjer sig ofta med 70%. Hur mycket kodtäckning man kan få är också beroende av hur testbar koden är. Är koden inte skriven för att vara testbar så kan man ge sig på att det är svårt att skriva testfall i enhetstester och uppnå hög kodtäckning.</p>
<p>Varje testfall i enhetstestet innebär att man anropar en eller flera metoder/funktioner i sitt testobjekt. Testobjektet är den kodmodul man testar. Efter anropet så verifierar man att ett förväntat utfall är uppfyllt. Man har alltså vissa förväntningar på vad som skall hända när koden körs och det skall man verifiera efter att koden körts. Vi kallar detta <em>assertions</em> (<a href="https://en.wikipedia.org/wiki/Assertion_(software_development)">Wikipedia om Assertion</a>) som är villkor som skall vara uppfyllda.</p>
<blockquote>
<p><em>“If there is no assertion, it isn’t a test.”</em></p>
</blockquote>
<p>När man tänker på test och utveckling av kod i samklang så tenderar man att skriva kod som också är testbar och enkel att testa. Det blir till en erfarenhet som sitter i ryggraden om att koden jag skriver måste gå att testa i enhetstester. Bäst att skriva den testbar med ett tydligt publikt API och resten skyddat. Här funderar jag på vad som kan injectas in i modulen och troligen tänker jag igenom vad som kan mockas och inte (<a href="https://en.wikipedia.org/wiki/Mock_object">Wikipedia om Mock object</a>), redan när jag utvecklar och skriver koden. När jag ser att jag skriver kod som är svår att testa så kan jag alltid välja att göra refactoring för att koden skall vara enklare att testa.</p>
<p>Det kan vara en klar skillnad mellan att skriva helt ny kod som man vill skall vara testbar, jämfört med att införa enhetstester för existerande kod. Man kan inte räkna med att den existerande koden är testbar ur alla aspekter. Som utvecklare måste man tänka på att skriva kod som är testbar, om man vill uppnå det. All kod som skrivs är inte testbar eller enkel att testa.</p>
<p>Varje testfall skall kunna köras isolerat från alla andra testfall. Man behöver alltså tänka på att varje test man skriver skall kunna köras oberoende av de andra testerna och oberoende av testernas inbördes ordning. Det brukar finnas stöd för att sätta upp en miljö för varje testfall och/eller suite av testfall. En bonus när man lyckas med detta är att alla tester kan köras parallellt. Det är en fördel när alla tester börjar ta längre tid, att köra tester parallellt snabbar upp och effektiviserar utvecklingsitden.</p>
<blockquote>
<p><em>“If the tests can not run independently, then they are not unit tests.”</em></p>
</blockquote>
<h4 id="testdriven-utveckling"><a href="#testdriven-utveckling">Testdriven utveckling</a></h4>
<p>TDD är förkortningen av testdriven utveckling (<a href="https://en.wikipedia.org/wiki/Test-driven_development">Wikipedia om Test-driven development</a>) som är en utvecklingsprocess som säger att man börjar skriva ett eller flera testfall och därefter skriver man koden för att lösa testfallen.</p>
<p>Vi kan förklara utvecklingsmodellen med följande steg.</p>
<ol>
<li>Skriv ett testfall.</li>
<li>Exekvera testsuiten och se testfallet misslyckas.</li>
<li>Skriv koden.</li>
<li>Kör testerna (alla passerar).</li>
<li>Refactor, skriv om, organisera om, kodbasen efterhand som den växer.</li>
<li>Repetera.</li>
</ol>
<p>I TDD pratar vi i termer om testfall och utvecklingen, koden vi skriver, drivs fram av de testfall vi lägger till och inte tvärtom. Det är alltså inte koden i sig som driver fram testfallen.</p>
<p>Som en bonus blir all vår kod testbar och troligen skriven för att vara högst testbar.</p>
<p>TDD får oss att skriva koden som löser testfallen, möjligen får det oss att fokusera på det som är viktigt i koden och möjligen ökar fokusen på att hålla kodmodulerna små.</p>
<h4 id="behaviour-driven-utveckling"><a href="#behaviour-driven-utveckling">Behaviour driven utveckling</a></h4>
<p>BDD är en vidareutveckling av TDD och står för Beteende-driven utveckling (<a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Wikipedia om Behavior-driven development</a>)
BDD. En intressant del i BDD är att man diskuterar systemet i features som skrivs ned i ett textdokument. Dessa features dokumenteras på ett sätt så att både programmerare och systemets slutanvändare och ledning kan förstå dem. Det blir ett material där verksamhetens olika roller kan diskutera hur systemet skall fungera. Man får ett egen språk att samtala om systemet.</p>
<p>Dessa features, berättelser om hur systemet skall fungera, kan sedan automatgenerera testfall som kan köras av programmeraren. Dessa kan sedan styra utvecklingen och koden som skrivs för att lösa feature för feature. Jämför med TDD där testfallen driver utvecklingen. Här är det features, och dess testfall, som driver utvecklingen.</p>
<p>Så här kan en feature vara skriven, exemplet är taget från <a href="https://github.com/mosbth/cimage/tree/resize/features"><code>mosbth/cimage</code></a>.</p>
<pre><code class="language-bash">Feature: src
    Display an image by selecting its source.

    Scenario: Source is not a valid image name
        Given Set src &quot;NO_IMAGE&quot;
        When Get headers for image
        Then Returns status code &quot;404&quot;

    Scenario: Get only source image
        Given Set src &quot;test_100x100.png&quot;
        When Get image
        Then Returns status code &quot;200&quot;
        And Compares to image &quot;test_100x100.png&quot;
</code></pre>
<p>I fallet ovan används programvaran <a href="http://behat.org/">Behat</a> för att parsa featuren och generera testbar kod och för att exekvera alla testfall. Den som jobbar med testsuiten behöver skriva en del kod för att hanteringen kring <code>Given</code>, <code>When</code>, <code>Then</code> och <code>And</code> skall fungera. Du kan se det som att termerna motsvaras av metoder som exekverar själva testfallen.</p>
<p>BDD kan vara en bra utvecklingmetodik som driven utvecklingen via testbar kod och erbjuder ett språk som både programmerare och icke-programmerare kan prata.</p>
<h4 id="funktionstester"><a href="#funktionstester">Funktionstester</a></h4>
<p>Låt oss benämna funktionstester (<a href="https://en.wikipedia.org/wiki/Functional_testing">Wikipedia om Functional testing</a>) som testar en feature, en systemfunktion. Ta ett exempel att “registrera en ny användare”. Ett sådant test innebär att man utför de steg som krävs för att registrera en användare. Det kan vara genom att använda ett grafiskt användargränssnitt (GUI), eller genom ett CLI-interface (Commandline interface) eller via ett API i koden eller ett publikt API via REST.</p>
<p>Funktionstester är i allmänhet <em>black-box tester</em> (<a href="https://en.wikipedia.org/wiki/Black-box_testing">Wikipedia om Black-box testing</a>) där man inte nödvändigtvis behöver ha koll på den underliggande koden. Man vill testa en systemfunktion och man bryr sig inte om vilka underliggande moduler som används.</p>
<p>Det kan finnas ett gränsområde där enhetstester övergår i funktionstester, gränsen går troligen någonstans där man slutar mocka och istället använder systemets riktiga moduler för att utföra en systemfunktion, med eller utan ett gränssnitt (GUI/CLI/API).</p>
<p>I webbsammanhang behöver man ofta utföra funktionstester i formen av en webbläsare, man vill simulera en webbläsare för att utföra hela åtgärden “registrera en ny användare”. I sådana fall finns det programvara som hjälper testaren att simulera knapptryck och analysera webbsidan som kommer tillbaka som svar. Programvaran benämns ofta <em>headless browser</em> (<a href="https://en.wikipedia.org/wiki/Headless_browser">Wikipedia om Headless browser</a>) och det kan vara ett viktigt verktyg i testning.</p>
<p>Det är alltmer vanligt att en webbtjänst både erbjuder ett (REST) API och ett traditionellt webb-GUI. Det kan göra webbtjänsten enklare att testa då ett (REST) API ger en tydlig bild av vad man kan göra med systemet. Ett traditionellt webb-GUI är inte nödvändigtvis lika tydligt om vad man kan göra och vilket resultat man får tillbaka.</p>
<h4 id="ovriga-tester"><a href="#ovriga-tester">Övriga tester</a></h4>
<p>Det finns många fler typer av tester som man kan vilja genomföra och kategorisera som egna typer av tester. Låt oss nämna några.</p>
<p>Integrationstester (<a href="https://en.wikipedia.org/wiki/Integration_testing">Wikipedia om Integration testing</a>) fokuserar på att testa att flera moduler kan samverka på ett tänkt sätt. Man ser det som ett steg i en CI pipeline (Continuous integration) att alla moduler, eller en delmängd av dem, behöver integreras i något steg och då vill man verifiera med en testsuite att integrationen gick bra. Likt alla testfaser behöver man bestämma kriteria för vad som skall testas, hur det skall testas och vad som bestämmer att testerna går bra.</p>
<p>I systemtestfasen (<a href="https://en.wikipedia.org/wiki/System_testing">Wikipedia om System testing</a>) utförs en serie av tester mot systemet som helhet. Alla moduler är på plats och systemet snurrar i en miljö som är relevant och motsvarar systemets verkliga driftsmiljö. Man kan utföra säkerhetstester, usabilitytester, prestandatester och stresstester eller tester av dokumentationen. Man tänker på systemet som helhet och testar de aspekter som är viktiga och relevanta. Systemtestet är en plats för att verifiera systemets icke-funktionella krav via icke-funktionella tester (<a href="https://en.wikipedia.org/wiki/Non-functional_testing">Wikipedia om Non-functional testing</a>).</p>
<p>Ett annat test som kan vara av vikt är acceptanstester (<a href="https://en.wikipedia.org/wiki/Acceptance_testing">Wikipedia om Acceptance testing</a>). Det är tester som utförs inför, tillsammans med, eller av kunden, när de tar emot leveransen. Där är ett viktigt dokument/fas som du och kunden gemensamt tagit fram som en del av beställningen och där testerna syftar till att verifiera att kunden verkligen fått leverans enligt beställning. Ur beställarens synpunkt kan acceptanstestet vara nästan lika viktigt som kravspecen då ett godkänt acceptanstest innebär att fakturan kan skickas och kunden har accepterat att systemet möter de kriteria som var viktigt.</p>
<p>Ibland kan kombinationen av Windows och npm modulen bcrypt ställa till med stora problem. Ett tips hämtat från <a href="https://github.com/kelektiv/node.bcrypt.js/wiki/Installation-Instructions#microsoft-windows">installationsmanualen för bcrypt</a> är att installare npm paketet <code>windows-build-tools</code> med kommandot nedan. Installera det i kommandotolken (cmd) eller Powershell så Windows har tillgång till det.</p>
<pre><code class="language-bash">npm install --global --production windows-build-tools
</code></pre>
</section><section id="kravspec"><h2><a href="#kravspec">kravspec</a></h2>
</article></section></div>    </main>

    <footer class="footer" id="footer">
        <div class="inner-footer">
            <p>&copy; <a href="https://emilfolino.se" target="_blank">Emil Folino</a></p>
            <p>This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</p>
            <p>The source code can be found at <a href="https://github.com/emilfolino/jsramverk.me">GitHub emilfolino/jsramverk.me</a></p>
        </div>
    </footer>
</body>
</html>
